<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 能工巧匠集 | OneV's Den]]></title>
  <link href="http://onevcat.com/category/neng-gong-qiao-jiang-ji/atom.xml" rel="self"/>
  <link href="http://onevcat.com/"/>
  <updated>2014-01-10T22:13:32+09:00</updated>
  <id>http://onevcat.com/</id>
  <author>
    <name><![CDATA[onevcat]]></name>
    <email><![CDATA[onev@onevcat.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[代码手写UI，xib和StoryBoard间的博弈，以及Interface Builder的一些小技巧]]></title>
    <link href="http://onevcat.com/2013/12/code-vs-xib-vs-storyboard/"/>
    <updated>2013-12-31T21:32:00+09:00</updated>
    <id>http://onevcat.com/2013/12/code-vs-xib-vs-storyboard</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/code-xib-sb.png" alt="Code-vs-Xibs-vs-StroyBoard" /></p>

<p>最近接触了几个刚入门的iOS学习者，他们之中存在一个普遍和困惑和疑问，就是应该如何制作UI界面。iOS应用是非常重视用户体验的，可以说绝大多数的应用成功与否与交互设计以及UI是否漂亮易用有着非常大的关系。而随着iOS开发发展至今，可以说在UI制作上大家逐渐分化为了三种主要流派：使用代码手写UI及布局；使用单个xib文件组织viewController或者view；使用StoryBoard来通过单个或很少的几个（关于这点稍后会进行展开）文件构建全部UI。应该使用哪种方式来制作UI已经是iOS开发中亘古不变的争论话题了，或许永远不会有一个统一的结论。但是首先需要知道的是三种方式各有优劣，所以也各有自己最适用的场合，而不会有完全的孰优孰劣。对于初学iOS开发来说，一时间其实是很难判定最适合自己的UI架构方式的。在这篇文章里我希望能够通过自己的经验给出一些意见，以期能帮助入门者来挑选最适合自己应用场景的方案。对于老鸟的话，也不妨对照自己平日的使用习惯和运用场景，看看有没有可以改进或变化的地方。最后，因为我本人现在最习惯和喜欢的是用Interface Builder(之后简称IB)及xib来做UI，所以文末附上了一些IB使用时候的小技巧，算是做个总结。</p>

<!--more-->


<h3>代码手写UI</h3>

<p>这种方法经常被学院派的极客或者依赖多人合作的大型项目大规模使用。Geek们喜欢用代码构建UI，是因为代码是键盘敲出来的，这样可以做到不开IB，手不离开键盘就完成工作，可以专注于编码环境，看起来很cool很高效，而且不到运行时大家都不知道会是什么样子，也显出了程序员这一职业的高大上及神秘气息（这个真的不是在黑..想想大家一起在设计师背后指点江山的场景吧）。大型多人合作项目使用代码构建UI，主要是看中纯代码在版本管理时的优势，检查追踪改动以及进行代码合并相对容易一些。</p>

<p>另外，代码UI可以说具有最好的代码重用性。如果你的目的是写一些可以高度重用的控件提供给其他开发者使用，那毫无疑问最好的选择应该是使用代码来完成UIView的子类。这样进一步的修改和其他开发者在使用时，都会方便不少。使用代码也是最为强大的，会有xib或者StoryBoard做不了的事情，但是使用代码最终一定能够完成所要的需求。</p>

<p>但是代码手写UI的劣势同时也是最明显的，主要就是一个字：慢。首先相比可视化的IB来说，完成一个并不太复杂的界面，你可能需要写上数百行的UI代码。不论是初始化一个Label，还是设定一个frame或者添加一个target-action，都需要写代码，这不仅在前期极为浪费时间，在之后维护时代码定位和寻找也会很痛苦。其次，因为你无法直观地看到你能得到的结果，所以你很可能需要不断地<code>Cmd+R</code>/<code>Cmd+.</code>来修改各个视图的位置大小。即使你用上了<a href="http://revealapp.com">Reveal</a>或者<a href="https://github.com/mikr/RestartLessOften">RestartLessOften</a>之类的工具，也还是无法特别方便地完成需要的布局。另外加上如果需要利用AutoLayout来进行尺寸适配的话，使用代码进行约束就更加头疼了。很多时候一个无法满足的约束的问题就够来回运行修改调试很长时间了。</p>

<h3>Xibs</h3>

<p>相对于代码，使用IB和xib文件来组织UI，可以省下大量代码和时间，从而得到更快的开发速度。如果你曾经受到过微软家Visual Basic或者其他Visual系的可视化界面的荼毒与残害，因此怀疑Interface Builder的纯正血统和工作能力，建议可以看看这些资料以纠正三观：<a href="http://www.programmer.com.cn/9234/">Jean-Marie Hullot的Interface Builder神话</a>，<a href="http://www.youtube.com/watch?v=viLnOVBbcsE">西装革履的青涩乔帮主在NeXT时亲手用IB构建应用</a>（需要翻墙）。另外，不妨打开你的Mac上的Application文件夹中或者iPhone上Apple家的各种应用。你会惊奇地发现，IB远比你看到的要强大：小至计算器取色器这类小工具，大至iWork三件套，Aperture或Final Cut这样的专业级应用，无一不是使用IB来完成UI制作的。</p>

<p>其实IB和xib是从iOS SDK初次面世开始就是捆绑在开发者工具套装内的内容了，而到了Xcode 4之后更被直接集成到了Xcode中成为了IDE的一部分。xib设计的一大目的其实是为了良好的MVC：一般来说，单个的xib文件对应一个ViewController，而对于一些自定义的view，往往也会使用单个xib并从main bundle进行加载的方式来载入。IB帮助完成view的创建，布局和与file owner的关系映射等一些列工作。对于初学者来说，牢记xib的文件都是view的内容，有助于建立起较好的MVC的概念，从而在开发中避免或少走弯路。</p>

<p>xib文件之前一大被诟病的问题是文件内容过于复杂，可读性很差，即使只是简单打开没有编辑也有可能造成变化而导致合并和提交的苦难。在Xcode 5中Apple大幅简化了xib文件的格式，使其变得易读易维护。可以说现在对于xib文件在版本管理上其实和纯代码已经没有太大差异，只要仔细看过一遍xib的文件内容，自然能理解绝大部分，并很好地追踪并查找过往的修改记录了。</p>

<p>当然xib也不是完美的。最大的问题在于xib中的设置往往并非最终设置，在代码中你将有机会覆盖你在xib文件中进行的UI设计。在不同的地方对同一个属性进行设置，这在之后的维护中将会是噩梦般的存在。因为其实IB还是有所局限的，它没有逻辑判断，也很难在运行时进行配置，而反之使用代码确是无所不能的。在使用xib时，辅以部分代码来补充和完成功能几乎是不可避免的。关于这点在开发时应该予以高度重视，如果选择xib，那么要尽量将xib的工作和代码的工作隔离开来：能够使用xib完成的内容就统一使用xib来做，而不要说三个Label其中两个在xib设置了字体而另一个却在代码中完成。尽量仅保持必要的、较少的IBOutlet和IBAction会是一个好方法。</p>

<h3>StoryBoard</h3>

<p>iOS5之后Apple提供了一种全新的方式来制作UI，那就是StoryBoard。简单理解来说，可以把StoryBoard看做是一组viewController对应的xib，以及它们之间的转换方式的集合。在StoryBoard中不仅可以看到每个ViewController的布局样式，也可以明确地知道各个ViewController之间的转换关系。相对于单个的xib，其代码需求更少，也由于集合了各个xib，使得对于界面的理解和修改的速度也得到了更大提升。减少代码量就是减少bug量，这也是程序开发中的真理之一。</p>

<p>在Xcode5之后，StoryBoard已经成为新建项目的默认配置，这也代表了Apple对开发者的建议和未来的方向。WWDC2013的各个Sample Code中也基本都使用了StoryBoard来进行演示。可以预见到，之后Apple必定会在这方面进行继续强化，而反之纯代码或者单个xib的方式很可能不会再得到增强。</p>

<p>如果不考虑iOS版本的支持（其实说实话现在已经很少还见到要从iOS4开始支持的app了吧），现在StoryBoard面临的最大问题就是多人协作。因为所有的UI都定义在一个文件中，因此很多开发者个人或企业的技术负责人认为StoryBoard是无法进行协作开发的，其实这更多的是一种对StoryBoard的陌生所造成的误解。虽然Apple并没有在WWDC明确提及，但是没有人规定整个项目只能有一个StoryBoard文件。一种可行的做法是将项目的不同部分分解成若干个StoryBoard，并安排开发人员对自己的部分进行负责。简单举例比如一个有4个tab功能相互独立的基于UITabBarViewController的应用，完全可以使用4个StoryBoard来分别代表4个tab，并在相互无干扰的情况下完成开发。这样一来就不会存在所谓的冲突问题了。StoryBoard的API是如此简单，现在的SDK中一共方法数量一只手就能数过来，所以具体方法在这里就不再罗嗦了。</p>

<p>StoryBoard的另外的挑战来源于ViewController的重用和自定义的view的处理。对于前者，在正确封装接口以及良好设计的基础上，其实StoryBoard的VC重用与代码的VC重用是没有本质区别的，在StoryBoard中添加封装良好需要重用的Scene即可解决。而对于后者，因为StoryBoard中已经不允许有单个view的存在，因此很多时候我们还是需要借助于单个的xib来自定义UI。这一点可以说是由于StoryBoard的设计思路所造成的，StoryBoard更强调的是一种层次结构，是在全局的视角上来组织UI设计和迁移。而对于单个的view，更多的会注重于重用和定制，而与整个项目的流程没有太大关系。相信抓住这一要点，就能很好地了解什么时候使用xib，什么时候使用StoryBoard。</p>

<p>关于StoryBoard最后要说的是，现在会有一些对于StoryBoard性能上的担忧。因为相对于单个xib来说，StoryBoard文件往往更大，加载速度也相应变慢。但是其实随着现在设备的更新换代，在iPhone4都难觅的今天，这点性能上的差距几乎可以忽略了。而再之后的设备，不论读取还是解析，只会越来越快。所以性能上的问题完全是没有担心的必要的。</p>

<h3>我的观点和选择</h3>

<p>我入门的时候是使用xib的，因为那时候还没有StoryBoard，而我也不是喜欢代码的学院派Geek。到现在，三种方式我都有尝试过，并分别得到了一些可能还并不是特别深刻体会。对于现在的我来说，xib是我的奶酪，也是我在自己的一些项目里一直使用的方式，我可以在极短短时间内用xib架起一套包括自定义要素和良好部件重用性复杂UI。但是在我尝试了几次使用StoryBoard制作demo之后，我已经决定在之后的项目转向使用StoryBoard。一方面因为确实是未来方向（每次新工程删StoryBoard很讨厌..），现在的StoryBoard专有的preview功能，以及之后AutoLayout的进一步改进等都很值得期待；另一方面也觉得奶酪放一个地方太久了会不好，趁着iOS7的大变革，也更新一下自己的观念和方式，把奶酪换个地方摆摆，也许会对以后大有裨益。</p>

<p>对于初心者来说，我并不建议上手就直接使用代码来进行UI制作和布局，因为冗长的UI代码确实非常乏味无趣。尽快看到成品，至少尽快看到原型，是保持兴趣，继续深入和从事职业的有效动力。所以如果有可能有条件，在老鸟的指导下选择StoryBoard来进行快速构建（或者如果是单个人开发的话，可以不用考虑多个StoryBoard协作，就更容易），会是入门的好选择。而最新的教程和文档已经开始逐渐偏向StoryBoard，关于StoryBoard的问题在SO上关注度也会更高，这样在入门时会有更多的资料可以进行参考。</p>

<p>这并不是说不需要关心代码UI或者xib，因为使用StoryBoard的时候在只能使用代码以及自定义单个view时，还是不可避免地需要接触它们的。这里想给的一点建议就是，虽然你不依赖代码来进行UI制作，但是了解并掌握如何使用纯代码来从头构建UI还是非常必要的：包括从新建Window开始，到初始化ViewController，添加必要的view，设定它们的property，以及添加和处理它们的各种响应及responser链等内容。现在iOS开发入门非常容易，Xcode和xib/StoryBoard帮助开发者隐藏了太多的细节，但是很多时候如果你不明白underhood到底是些什么，为什么这些xib/StoryBoard会这样运作的话，经常会出现卡在一些很可笑的和初级的bug上找不着北，这其实会是对时间的巨大浪费，很不值得。</p>

<h3>一些IB小技巧</h3>

<p>最后分享一些IB使用上的小技巧作为结束吧。其中很多方法也可以用在StoryBoard上，所以在向我自己之前xib使用者生涯致敬的同时，也算是一点小的备忘总结吧。</p>

<h4>同时添加多个outlet</h4>

<p>在IB中，选中一个view并右键点击，将会出现灰色的HUD，可以在其上方便地拖拉或设定事件和outlet。你可以同时打开多个这样的面板来一次性添加所有outlet。右键点击面板，随便拖动一下面板，然后再打开另一个。你会发现前一个面板也留下来了，这样你就可以方便地进行拖拽设定了。</p>

<p><img src="http://img.onevcat.com/2013/IB-tip1.png" alt="多个Outlet HUD" /></p>

<p>当然，对于成组和行为类似的IBOutlet，应该直接使用IBOutletCollection来进行处理会更方便。</p>

<h4>可视化坐标距离</h4>

<p>IB最烦人的问题就是对其。用代码的时候我们可以明确地指定x,y坐标，但是换到IB的时候我们更多的时候是靠拖拽UIView来布局。比如需要三个间隔相同的label，除了用强大的肉眼来估测距离是否相等以外，难道只能乖乖分别选中三个label，记下它们的坐标然后打开计算器来做加减法么？</p>

<p>显然不要那么笨，试试看选中一个label，然后按住option键并将鼠标移动到其他label上试试？你可以发现view之间的距离都以很容易理解的方式显示出来了。不仅是同层次的view，被选中view与其他层次的view之间的距离关系也可以同样显示。</p>

<p><img src="http://img.onevcat.com/2013/IB-tip2.png" alt="显示View之间的距离" /></p>

<h4>在一组view层次中进行选择</h4>

<p>对于一些复杂的view层级关系，我们往往直接在IB中选择会比较困难。比如view相互覆盖时，我们很难甚至不能在编辑视图中选中底层的view。这时候一般的做法是打开左侧的view层级面板，一层层展开然后选择自己需要的view。其实我们也有更简单的方法：按住<code>Cmd</code>和<code>Shift</code>，然后在需要选择的view上方按右键，就可以列出在点击位置上所有的view的列表。藉此就可以方便快速地选中想要的view了。</p>

<p><img src="http://img.onevcat.com/2013/IB-tip3.png" alt="在编辑视图中选则底层view" /></p>

<h4>添加辅助线</h4>

<p>这么高大上的技巧必须放在最后啊...在左边的层级列表中双击某个view，然后<code>Cmd+_</code>或者<code>Cmd+|</code>即可在选中的view上添加一条水平或者垂直中心的辅助线。当然这个辅助线是可以随意移动的。如果干过设计的同学肯定明白这个的意义了，在之后的对其和设计变更的时候都有重要的参考价值。</p>

<p><img src="http://img.onevcat.com/2013/IB-tip4.png" alt="为IB添加辅助线" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS内购实现及测试Check List]]></title>
    <link href="http://onevcat.com/2013/11/ios-iap-checklist/"/>
    <updated>2013-11-18T22:08:00+09:00</updated>
    <id>http://onevcat.com/2013/11/ios-iap-checklist</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/cannot-connect-its.png" alt="image" /></p>

<p>免费+应用内购买的模式已经被证明了是最有效的盈利模式，所以实现内购功能可能是很多开发者必做的工作和必备的技能了。但是鉴于内购这块坑不算少，另外因为sandbox测试所需要特定的配置也很多，所以对于经验不太多的开发者来说很容易就遇到各种问题，并且测试时出错Apple给出的也只有“Can not connect iTunes Store”或者"Invalid Product IDs"之类毫无价值的错误提示，并没有详细的错误说明，因此调试起来往往没有方向。有老前辈在<a href="http://troybrant.net/blog/2010/01/invalid-product-ids/">这里</a>整理过一个相对完整的check list了，但是因为年代已经稍微久远，所以内容上和现在的情况已经有一些出入。趁着在最近两个项目里做内购这块遇到的新问题，顺便在此基础上总结整理了一份比较新的中文Check list，希望能帮到后来人。</p>

<p>如果您在实现和测试iOS应用内购的时候遇到问题，可以逐一对照下面所列出的条目，并逐一进行检查。相信可以排除大部分的错误。如果您遇到的问题不在这个列表范围内，欢迎在评论中指出，我会进行更新。</p>

<ul>
<li>您是否在iOS Dev Center中打开了对应应用AppID的<code>In-App Purchases</code>功能？登陆iOS Dev Center的Certificates, Identifiers &amp; Profiles下，在Identifiers中找到正在开发的App，In-App Purchase一项应当显示Enabled（如果使用Xcode5，可以直接在Xcode的Capabilities页面中打开In-App Purchases）。</li>
<li>您是否在iTunes Connect中注册了您的IAP项目，并将其设为Cleared for Sale？</li>
<li>您的plist中的<code>Bundle identifier</code>的内容是否和您的AppID一致？</li>
<li>您是否正确填写了Version（CFBundleVersion）和Build（CFBuildNumber）两个数字？两者缺一不可。</li>
<li>您用代码向Apple申请售卖物品列表时是否使用了完整的在iTC注册的Product ID？（使用在IAP管理中内购项目的Product ID一栏中的字符串）</li>
<li>您是否在打开IAP以后重新生成过包含IAP许可的provisioning profile？</li>
<li>你是否重新导入了新的包含IAP的provisioning profile？建议在Organizer中先删掉原来设备上的老的provisioning profile。</li>
<li>您是否在用包含IAP的provisioning profile在部署测试程序？在Xcode5中，建议使用General中的Team选项来自动管理。</li>
<li>您是否是在模拟器中测试IAP？虽然理论上说模拟器在某些情况下可以测试IAP，但是条件很多也不让人安心，因此您确实需要一台真机来做IAP测试。</li>
<li>您是在企业版发布中测试IAP么？因为企业版没有iTC进行内购项目管理，也无法发布AppStore应用，所以您在企业版的build中不能使用IAP。</li>
<li>您是否将设备上原来的app删除了，并重新进行了安装？记得在安装前做一下Clean和Clean Build Folder。</li>
<li>您是否在运行应用前将设备上实际的Apple ID登出了？建议在设置->iTunes Store和App Stroe中将使用中的Apple ID登出，以未登录状态进入应用进行测试。</li>
<li>你是否使用的是Test User？如果你还没有创建Test User，你需要到iTC中创建。</li>
<li>您使用的测试账号是否是美国区账号？虽然不是一定需要，但是鉴于其他地区的测试账号经常抽风，加上美国区账号一直很稳定，因此强烈建议使用美国区账号。正常情况下IAP不需要进行信用卡绑定和其他信息填写，如果你遇到了这种情况，可以试试删除这个测试账号再新建一个其他地区的。</li>
<li>您是否有新建账户进行测试？可能的话，可以使用新建测试账户试试看，因为某些特定情况下测试账户会被Apple锁定。</li>
<li>您的应用是否是被拒状态（Rejected）或自己拒绝（Developer Rejected）了？被拒绝状态的应用的话对应还未通过的内购项目也会一起被拒，因此您需要重新将IAP项目设为Cleared for Sale。</li>
<li>您的应用是否处于等待开发者发布（Pending Developer Release）状态？等待发布状态的IAP是无法测试的。</li>
<li>您的内购项目是否是最近才新建的，或者进行了更改？内购项目需要一段时间才能反应到所有服务器上，这个过程一般是一两小时，也可能再长一些达到若干小时。</li>
<li>您在iTC中Contracts, Tax, and Banking Information项目中是否有还没有设置或者过期了的项目？不完整的财务信息无法进行内购测试。</li>
<li>您是在越狱设备上进行内购测试么？越狱设备不能用于正常内购，您需要重装或者寻找一台没有越狱的设备。</li>
<li>您是否能正常连接到Apple的服务器，你可以访问<a href="https://devforums.apple.com/community/ios/connected/purchase">Apple开发者论坛关于IAP的板块</a>，如果苹果服务器正down掉，那里应该有热烈的讨论。</li>
</ul>


<hr />

<p>如果您正在寻找一份手把手教你实现IAP的教程的话，这篇文章不是您的菜。关于IAP的实现和步骤，可以参考下面的教程：</p>

<ul>
<li>苹果的<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html">官方IAP指南</a>和相应的<a href="https://developer.apple.com/library/mac/technotes/tn2259/_index.html">Technical Note</a></li>
<li>Ray Wenderlich的<a href="http://www.raywenderlich.com/23266/in-app-purchases-in-ios-6-tutorial-consumables-and-receipt-validation">iOS6 IAP教程</a></li>
<li>一篇图文并茂的<a href="http://blog.csdn.net/xiaominghimi/article/details/6937097">中文教程</a></li>
<li>直接使用大神们封好的Store有关的库，比如<a href="https://github.com/mattt/CargoBay">mattt/CargoBay</a>，<a href="https://github.com/robotmedia/RMStore">robotmedia/RMStore</a>或者<a href="https://github.com/MugunthKumar/MKStoreKit">MugunthKumar/MKStoreKit</a>。推荐前两个，因为MKStoreKit有一些恼人的小bug。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC 2013 Session笔记 - iOS7中的ViewController切换]]></title>
    <link href="http://onevcat.com/2013/10/vc-transition-in-ios7/"/>
    <updated>2013-10-11T15:36:00+09:00</updated>
    <id>http://onevcat.com/2013/10/vc-transition-in-ios7</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/ios-transition-banner.jpg" alt="iOS7中的ViewController切换" /></p>

<p>这是我的WWDC2013系列笔记中的一篇，完整的笔记列表请参看<a href="http://onevcat.com/2013/06/developer-should-know-about-ios7/">这篇总览</a>。本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">许可协议</a>范围内转载或使用，但是还烦请保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://onevcat.com/atom.xml">RSS</a>或<a href="http://eepurl.com/wNSkj">邮件</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>

<p>本文涉及到的WWDC2013 Session有</p>

<ul>
<li>Session 201 Building User Interfaces for iOS 7</li>
<li>Session 218 Custom Transitions Using View Controllers</li>
<li>Session 226 Implementing Engaging UI on iOS</li>
</ul>


<p>毫无疑问，ViewController（在本文中简写为VC）是使用MVC构建Cocoa或者CocoaTouch程序时最重要的一个类，我们的日常工作中一般来说最花费时间和精力的也是在为VC部分编写代码。苹果产品是注重用户体验的，而对细节进行琢磨也是苹果对于开发者一直以来的要求和希望。在用户体验中，VC之间的关系，比如不同VC之间迁移和转换动画效果一直是一个值得不断推敲的重点。在iOS7中，苹果给出了一套完整的VC制作之间迁移效果的方案，可以说是为现在这部分各种不同实现方案指出了一条推荐的统一道路。</p>

<h3>iOS 7 SDK之前的VC切换解决方案</h3>

<p>在深入iOS 7的VC切换效果的新API实现之前，先让我们回顾下现在的一般做法吧。这可以帮助理解为什么iOS7要对VC切换给出新的解决方案，如果您对iOS 5中引入的VC容器比较熟悉的话，可以跳过这节。</p>

<!--more-->


<p>在iOS5和iOS6中，除了标准的Push，Tab和PresentModal之外，一般是使用ChildViewController的方式来完成VC之间切换的过渡效果。ChildViewController和自定义的Controller容器是iOS 5 SDK中加入的，可以用来生成自定义的VC容器，简单来说典型的一种用法类似这样：</p>

<p>```objc
//ContainerVC.m</p>

<p>[self addChildViewController:toVC];
[fromVC willMoveToParentViewController:nil];
[self.view addSubview:toVC.view];</p>

<p>__weak id weakSelf = self;
[self transitionFromViewController:fromVC</p>

<pre><code>              toViewController:toVC duration:0.3
                       options:UIViewAnimationOptionTransitionCrossDissolve
                    animations:^{}
                    completion:^(BOOL finished) {
[fromVC.view removeFromSuperView];
[fromVC removeFromParentViewController];
[toVC didMoveToParentViewController:weakSelf];
</code></pre>

<p>}];
```</p>

<p>在自己对view进行管理的同时，可以使用transitionFromViewController:toViewController:...的Animation block中可以实现一些简单的切换效果。去年年初我写的<a href="http://onevcat.com/2012/02/uiviewcontroller/">UIViewController的误用</a>一文中曾经指出类似<code>[viewController.view addSubview:someOtherViewController.view];</code>这样的代码的存在，一般就是误用VC。这个结论适用于非Controller容器，对于自定义的Controller容器来说，向当前view上添加其他VC的view是正确的做法（当然不能忘了也将VC本身通过<code>addChildViewController:</code>方法添加到容器中）。</p>

<p>VC容器的主要目的是解决将不同VC添加到同一个屏幕上的需求，以及可以提供一些简单的自定义切换效果。使用VC容器可以使view的关系正确，使添加的VC能够正确接收到例如屏幕旋转，viewDidLoad:等VC事件，进而进行正确相应。VC容器确实可以解决一部分问题，但是也应该看到，对于自定义切换效果来说，这样的解决还有很多不足。首先是代码高度耦合，VC切换部分的代码直接写在container中，难以分离重用；其次能够提供的切换效果比较有限，只能使用UIView动画来切换，管理起来也略显麻烦。iOS 7提供了一套新的自定义VC切换，就是针对这两个问题的。</p>

<h3>iOS 7 自定义ViewController动画切换</h3>

<h4>自定义动画切换的相关的主要API</h4>

<p>在深入之前，我们先来看看新SDK中有关这部分内容的相关接口以及它们的关系和典型用法。这几个接口和类的名字都比较相似，但是还是能比较好的描述出各自的职能的，一开始的话可能比较迷惑，但是当自己动手实现一两个例子之后，它们之间的关系就会逐渐明晰起来。（相关的内容都定义在UIKit的<a href="https://gist.github.com/onevcat/6944809">UIViewControllerTransitioning.h</a>中了）</p>

<h4>@protocol <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerContextTransitioning_protocol/Reference/Reference.html">UIViewControllerContextTransitioning</a></h4>

<p>这个接口用来提供切换上下文给开发者使用，包含了从哪个VC到哪个VC等各类信息，一般不需要开发者自己实现。具体来说，iOS7的自定义切换目的之一就是切换相关代码解耦，在进行VC切换时，做切换效果实现的时候必须要需要切换前后VC的一些信息，<strong>系统在新加入的API的比较的地方都会提供一个实现了该接口的对象</strong>，以供我们使用。</p>

<p><strong>对于切换的动画实现来说</strong>（这里先介绍简单的动画，在后面我会再引入手势驱动的动画），这个接口中最重要的方法有：</p>

<ul>
<li>-(UIView *)containerView; VC切换所发生的view容器，开发者应该将切出的view移除，将切入的view加入到该view容器中。</li>
<li>-(UIViewController <em>)viewControllerForKey:(NSString </em>)key; 提供一个key，返回对应的VC。现在的SDK中key的选择只有UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别表示将要切出和切入的VC。</li>
<li>-(CGRect)initialFrameForViewController:(UIViewController *)vc; 某个VC的初始位置，可以用来做动画的计算。</li>
<li>-(CGRect)finalFrameForViewController:(UIViewController *)vc; 与上面的方法对应，得到切换结束时某个VC应在的frame。</li>
<li>-(void)completeTransition:(BOOL)didComplete; 向这个context报告切换已经完成。</li>
</ul>


<h4>@protocol <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerAnimatedTransitioning_Protocol/Reference/Reference.html">UIViewControllerAnimatedTransitioning</a></h4>

<p>这个接口负责切换的具体内容，也即“切换中应该发生什么”。开发者在做自定义切换效果时大部分代码会是用来实现这个接口。它只有两个方法需要我们实现：</p>

<ul>
<li><p>-(NSTimeInterval)transitionDuration:(id &lt; UIViewControllerContextTransitioning >)transitionContext; 系统给出一个切换上下文，我们根据上下文环境返回这个切换所需要的花费时间（一般就返回动画的时间就好了，SDK会用这个时间来在百分比驱动的切换中进行帧的计算，后面再详细展开）。</p></li>
<li><p>-(void)animateTransition:(id &lt; UIViewControllerContextTransitioning >)transitionContext; 在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</p></li>
</ul>


<h4>@protocol <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIViewControllerTransitioningDelegate_protocol/Reference/Reference.html">UIViewControllerTransitioningDelegate</a></h4>

<p>这个接口的作用比较简单单一，在需要VC切换的时候系统会像实现了这个接口的对象询问是否需要使用自定义的切换效果。这个接口共有四个类似的方法：</p>

<ul>
<li><p>-(id&lt; UIViewControllerAnimatedTransitioning >)animationControllerForPresentedController:(UIViewController <em>)presented presentingController:(UIViewController </em>)presenting sourceController:(UIViewController *)source;</p></li>
<li><p>-(id&lt; UIViewControllerAnimatedTransitioning >)animationControllerForDismissedController:(UIViewController *)dismissed;</p></li>
<li><p>-(id&lt; UIViewControllerInteractiveTransitioning >)interactionControllerForPresentation:(id &lt; UIViewControllerAnimatedTransitioning >)animator;</p></li>
<li><p>-(id&lt; UIViewControllerInteractiveTransitioning >)interactionControllerForDismissal:(id &lt; UIViewControllerAnimatedTransitioning >)animator;</p></li>
</ul>


<p>前两个方法是针对动画切换的，我们需要分别在呈现VC和解散VC时，给出一个实现了UIViewControllerAnimatedTransitioning接口的对象（其中包含切换时长和如何切换）。后两个方法涉及交互式切换，之后再说。</p>

<h3>Demo</h3>

<p>还是那句话，一百行的讲解不如一个简单的小Demo，于是..it's demo time～ 整个demo的代码我放到了github的<a href="https://github.com/onevcat/VCTransitionDemo">这个页面</a>上，有需要的朋友可以参照着看这篇文章。</p>

<p>我们打算做一个简单的自定义的modalViewController的切换效果。普通的present modal VC的效果大家都已经很熟悉了，这次我们先实现一个自定义的类似的modal present的效果，与普通效果不同的是，我们希望modalVC出现的时候不要那么乏味的就简单从底部出现，而是带有一个弹性效果（这里虽然是弹性，但是仅指使用UIView的模拟动画，而不设计iOS 7的另一个重要特性UIKit Dynamics。用UIKit Dynamics当然也许可以实现更逼真华丽的效果，但是已经超出本文的主题范畴了，因此不在这里展开了。关于UIKit Dynamics，可以参看我之前关于这个主题的<a href="http://onevcat.com/2013/06/uikit-dynamics-started/">一篇介绍</a>）。我们首先实现简单的ModalVC弹出吧..这段非常基础，就交待了一下背景，非初级人士请跳过代码段..</p>

<p>先定义一个ModalVC，以及相应的protocal和delegate方法：</p>

<p>```objc
//ModalViewController.h</p>

<p>@class ModalViewController;
@protocol ModalViewControllerDelegate <NSObject></p>

<p>-(void) modalViewControllerDidClickedDismissButton:(ModalViewController *)viewController;</p>

<p>@end</p>

<p>@interface ModalViewController : UIViewController
@property (nonatomic, weak) id<ModalViewControllerDelegate> delegate;
@end</p>

<p>//ModalViewController.m
- (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view.
self.view.backgroundColor = [UIColor lightGrayColor];

UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0);
[button setTitle:@"Dismiss me" forState:UIControlStateNormal];
[button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];
[self.view addSubview:button];
</code></pre>

<p>}</p>

<p>-(void) buttonClicked:(id)sender
{</p>

<pre><code>if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(modalViewControllerDidClickedDismissButton:)]) {
    [self.delegate modalViewControllerDidClickedDismissButton:self];
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这个是很标准的modalViewController的实现方式了。需要多嘴一句的是，在实际使用中有的同学喜欢在-buttonClicked:中直接给self发送dismissViewController的相关方法。在现在的SDK中，如果当前的VC是被显示的话，这个消息会被直接转发到显示它的VC去。但是这并不是一个好的实现，违反了程序设计的哲学，也很容易掉到坑里，具体案例可以参看<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/#comment-1052782406">这篇文章的评论</a>。</p>

<p>所以我们用标准的方式来呈现和解散这个VC：</p>

<p>```objc
//MainViewController.m</p>

<ul>
<li>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view.
  UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
  button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0);
  [button setTitle:@"Click me" forState:UIControlStateNormal];
  [button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];
  [self.view addSubview:button];
}</li>
</ul>


<p>-(void) buttonClicked:(id)sender
{</p>

<pre><code>ModalViewController *mvc =  [[ModalViewController alloc] init];
mvc.delegate = self;
[self presentViewController:mvc animated:YES completion:nil];
</code></pre>

<p>}</p>

<p>-(void)modalViewControllerDidClickedDismissButton:(ModalViewController *)viewController
{</p>

<pre><code>[self dismissViewControllerAnimated:YES completion:nil];
</code></pre>

<p>}
```</p>

<p>测试一下，没问题，然后我们可以开始实现自定义的切换效果了。首先我们需要一个实现了UIViewControllerAnimatedTransitioning的对象..嗯，新建一个类来实现吧，比如BouncePresentAnimation：</p>

<p>```objc
//BouncePresentAnimation.h
@interface BouncePresentAnimation : NSObject<UIViewControllerAnimatedTransitioning></p>

<p>@end</p>

<p>//BouncePresentAnimation.m
- (NSTimeInterval)transitionDuration:(id <UIViewControllerContextTransitioning>)transitionContext
{</p>

<pre><code>return 0.8f;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)animateTransition:(id <UIViewControllerContextTransitioning>)transitionContext
{
  // 1. Get controllers from transition context
  UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</p>

<p>  // 2. Set init frame for toVC
  CGRect screenBounds = [[UIScreen mainScreen] bounds];
  CGRect finalFrame = [transitionContext finalFrameForViewController:toVC];
  toVC.view.frame = CGRectOffset(finalFrame, 0, screenBounds.size.height);</p>

<p>  // 3. Add toVC's view to containerView
  UIView *containerView = [transitionContext containerView];
  [containerView addSubview:toVC.view];</p>

<p>  // 4. Do animate now
  NSTimeInterval duration = [self transitionDuration:transitionContext];
  [UIView animateWithDuration:duration</p>

<pre><code>                    delay:0.0
   usingSpringWithDamping:0.6
    initialSpringVelocity:0.0
                  options:UIViewAnimationOptionCurveLinear
               animations:^{
                   toVC.view.frame = finalFrame;
               } completion:^(BOOL finished) {
                   // 5. Tell context that we completed.
                   [transitionContext completeTransition:YES];
               }];
</code></pre>

<p>}
```</p></li>
</ul>


<p>解释一下这个实现：</p>

<ol>
<li>我们首先需要得到参与切换的两个ViewController的信息，使用context的方法拿到它们的参照；</li>
<li>对于要呈现的VC，我们希望它从屏幕下方出现，因此将初始位置设置到屏幕下边缘；</li>
<li>将view添加到containerView中；</li>
<li>开始动画。这里的动画时间长度和切换时间长度一致，都为0.8s。usingSpringWithDamping的UIView动画API是iOS7新加入的，描述了一个模拟弹簧动作的动画曲线，我们在这里只做使用，更多信息可以参看<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/UIView/UIView.html#//apple_ref/occ/clm/UIView/animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:">相关文档</a>；（顺便多说一句，iOS7中对UIView动画添加了一个很方便的Category，UIViewKeyframeAnimations。使用其中方法可以为UIView动画添加关键帧动画）</li>
<li>在动画结束后我们必须向context报告VC切换完成，是否成功（在这里的动画切换中，没有失败的可能性，因此直接pass一个YES过去）。系统在接收到这个消息后，将对VC状态进行维护。</li>
</ol>


<p>接下来我们实现一个UIViewControllerTransitioningDelegate，应该就能让它工作了。简单来说，一个比较好的地方是直接在MainViewController中实现这个接口。在MainVC中声明实现这个接口，然后加入或变更为如下代码：</p>

<p>```objc
@interface MainViewController ()&lt;ModalViewControllerDelegate, UIViewControllerTransitioningDelegate>
@property (nonatomic, strong) BouncePresentAnimation *presentAnimation;
@end</p>

<p>@implementation MainViewController</p>

<ul>
<li>(id)initWithNibName:(NSString <em>)nibNameOrNil bundle:(NSBundle </em>)nibBundleOrNil
{
  self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
  if (self) {

<pre><code>  // Custom initialization
  _presentAnimation = [BouncePresentAnimation new];
</code></pre>

<p>  }
  return self;
}</p></li>
</ul>


<p>-(void) buttonClicked:(id)sender
{</p>

<pre><code>//...
mvc.transitioningDelegate = self;
//...
</code></pre>

<p>}</p>

<ul>
<li>(id <UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController <em>)presented presentingController:(UIViewController </em>)presenting sourceController:(UIViewController *)source
{
  return self.presentAnimation;
}
```</li>
</ul>


<p>Believe or not, we have done. 跑一下，应该可以得到如下效果：</p>

<p><img src="http://img.onevcat.com/2013/custom-vc-transition-1.gif" alt="BouncePresentAnimation的实际效果" /></p>

<h3>手势驱动的百分比切换</h3>

<p>iOS7引入了一种手势驱动的VC切换的方式（交互式切换）。如果你使用系统的各种应用，在navViewController里push了一个新的VC的话，返回时并不需要点击左上的Back按钮，而是通过从屏幕左侧划向右侧即可完成返回操作。而在这个操作过程中，我们甚至可以撤销我们的手势，以取消这次VC转移。在新版的Safari中，我们甚至可以用相同的手势来完成网页的后退功能（所以很大程度上来说屏幕底部的工具栏成为了摆设）。如果您还不知道或者没太留意过这个改动，不妨现在就拿手边的iOS7这辈试试看，手机浏览的朋友记得切回来哦 :)</p>

<p>我们这就动手在自己的VC切换中实现这个功能吧，首先我们需要在刚才的知识基础上补充一些东西：</p>

<p>首先是UIViewControllerContextTransitioning，刚才提到这个是系统提供的VC切换上下文，如果您深入看了它的头文件描述的话，应该会发现其中有三个关于InteractiveTransition的方法，正是用来处理交互式切换的。但是在初级的实际使用中我们其实可以不太理会它们，而是使用iOS 7 SDK已经给我们准备好的一个现成转为交互式切换而新加的类：UIPercentDrivenInteractiveTransition。</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPercentDrivenInteractiveTransition_class/Reference/Reference.html">UIPercentDrivenInteractiveTransition</a>是什么</h4>

<p>这是一个实现了UIViewControllerInteractiveTransitioning接口的类，为我们预先实现和提供了一系列便利的方法，可以用一个百分比来控制交互式切换的过程。一般来说我们更多地会使用某些手势来完成交互式的转移（当然用的高级的话用其他的输入..比如声音，iBeacon距离或者甚至面部微笑来做输入驱动也无不可，毕竟想象无极限嘛..），这样使用这个类（一般是其子类）的话就会非常方便。我们在手势识别中只需要告诉这个类的实例当前的状态百分比如何，系统便根据这个百分比和我们之前设定的迁移方式为我们计算当前应该的UI渲染，十分方便。具体的几个重要方法：</p>

<ul>
<li>-(void)updateInteractiveTransition:(CGFloat)percentComplete 更新百分比，一般通过手势识别的长度之类的来计算一个值，然后进行更新。之后的例子里会看到详细的用法</li>
<li>-(void)cancelInteractiveTransition 报告交互取消，返回切换前的状态</li>
<li>–(void)finishInteractiveTransition 报告交互完成，更新到切换后的状态</li>
</ul>


<h4>@protocol <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIViewControllerInteractiveTransitioning_protocol/Reference/Reference.html">UIViewControllerInteractiveTransitioning</a></h4>

<p>就如上面提到的，UIPercentDrivenInteractiveTransition只是实现了这个接口的一个类。为了实现交互式切换的功能，我们需要实现这个接口。因为大部分时候我们其实不需要自己来实现这个接口，因此在这篇入门中就不展开说明了，有兴趣的童鞋可以自行钻研。</p>

<p>还有就是上面提到过的UIViewControllerTransitioningDelegate中的返回Interactive实现对象的方法，我们同样会在交互式切换中用到它们。</p>

<h3>继续Demo</h3>

<p>Demo time again。在刚才demo的基础上，这次我们用一个向上划动的手势来吧之前呈现的ModalViewController给dismiss掉～当然是交互式的切换，可以半途取消的那种。</p>

<p>首先新建一个类，继承自UIPercentDrivenInteractiveTransition，这样我们可以省不少事儿。</p>

<p>```objc
//SwipeUpInteractiveTransition.h
@interface SwipeUpInteractiveTransition : UIPercentDrivenInteractiveTransition</p>

<p>@property (nonatomic, assign) BOOL interacting;</p>

<ul>
<li>(void)wireToViewController:(UIViewController*)viewController;</li>
</ul>


<p>@end</p>

<p>//SwipeUpInteractiveTransition.m
@interface SwipeUpInteractiveTransition()
@property (nonatomic, assign) BOOL shouldComplete;
@property (nonatomic, strong) UIViewController *presentingVC;
@end</p>

<p>@implementation SwipeUpInteractiveTransition
-(void)wireToViewController:(UIViewController *)viewController
{</p>

<pre><code>self.presentingVC = viewController;
[self prepareGestureRecognizerInView:viewController.view];
</code></pre>

<p>}</p>

<ul>
<li>(void)prepareGestureRecognizerInView:(UIView<em>)view {
  UIPanGestureRecognizer </em>gesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
  [view addGestureRecognizer:gesture];
}</li>
</ul>


<p>-(CGFloat)completionSpeed
{</p>

<pre><code>return 1 - self.percentComplete;
</code></pre>

<p>}</p>

<ul>
<li>(void)handleGesture:(UIPanGestureRecognizer *)gestureRecognizer {
  CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view.superview];
  switch (gestureRecognizer.state) {

<pre><code>  case UIGestureRecognizerStateBegan:
      // 1. Mark the interacting flag. Used when supplying it in delegate.
      self.interacting = YES;
      [self.presentingVC dismissViewControllerAnimated:YES completion:nil];
      break;
  case UIGestureRecognizerStateChanged: {
      // 2. Calculate the percentage of guesture
      CGFloat fraction = translation.y / 400.0;
      //Limit it between 0 and 1
      fraction = fminf(fmaxf(fraction, 0.0), 1.0);
      self.shouldComplete = (fraction &gt; 0.5);

      [self updateInteractiveTransition:fraction];
      break;
  }
  case UIGestureRecognizerStateEnded:
  case UIGestureRecognizerStateCancelled: {
      // 3. Gesture over. Check if the transition should happen or not
      self.interacting = NO;
      if (!self.shouldComplete || gestureRecognizer.state == UIGestureRecognizerStateCancelled) {
          [self cancelInteractiveTransition];
      } else {
          [self finishInteractiveTransition];
      }
      break;
  }
  default:
      break;
</code></pre>

<p>  }
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>有点长，但是做的事情还是比较简单的。</p>

<ol>
<li>我们设定了一个BOOL变量来表示是否处于切换过程中。这个布尔值将在监测到手势开始时被设置，我们之后会在调用返回这个InteractiveTransition的时候用到。</li>
<li>计算百分比，我们设定了向下划动400像素或以上为100%，每次手势状态变化时根据当前手势位置计算新的百分比，结果被限制在0～1之间。然后更新InteractiveTransition的百分数。</li>
<li>手势结束时，把正在切换的标设置回NO，然后进行判断。在2中我们设定了手势距离超过设定一半就认为应该结束手势，否则就应该返回原来状态。在这里使用其进行判断，已决定这次transition是否应该结束。</li>
</ol>


<p>接下来我们需要添加一个向下移动的UIView动画，用来表现dismiss。这个十分简单，和BouncePresentAnimation很相似，写一个NormalDismissAnimation的实现了UIViewControllerAnimatedTransitioning接口的类就可以了，本文里略过不写了，感兴趣的童鞋可以自行查看源码。</p>

<p>最后调整MainViewController的内容，主要修改点有三个地方：</p>

<p>```objc
//MainViewController.m
@interface MainViewController ()&lt;ModalViewControllerDelegate,UIViewControllerTransitioningDelegate>
//...
// 1. Add dismiss animation and transition controller
@property (nonatomic, strong) NormalDismissAnimation <em>dismissAnimation;
@property (nonatomic, strong) SwipeUpInteractiveTransition </em>transitionController;
@end</p>

<p>@implementation MainViewController</p>

<ul>
<li>(id)initWithNibName:(NSString <em>)nibNameOrNil bundle:(NSBundle </em>)nibBundleOrNil
{
  //...

<pre><code>  _dismissAnimation = [NormalDismissAnimation new];
  _transitionController = [SwipeUpInteractiveTransition new];
</code></pre>

<p>  //...
}</p></li>
</ul>


<p>-(void) buttonClicked:(id)sender
{</p>

<pre><code>//...
// 2. Bind current VC to transition controller.
[self.transitionController wireToViewController:mvc];
//...
</code></pre>

<p>}</p>

<p>// 3. Implement the methods to supply proper objects.
-(id<UIViewControllerAnimatedTransitioning>)animationControllerForDismissedController:(UIViewController *)dismissed
{</p>

<pre><code>return self.dismissAnimation;
</code></pre>

<p>}</p>

<p>-(id<UIViewControllerInteractiveTransitioning>)interactionControllerForDismissal:(id<UIViewControllerAnimatedTransitioning>)animator {</p>

<pre><code>return self.transitionController.interacting ? self.transitionController : nil;
</code></pre>

<p>}</p>

<p>```</p>

<ol>
<li>在其中添加dismiss时候的动画和交互切换Controller</li>
<li>在初始化modalVC的时候为交互切换的Controller绑定VC</li>
<li>为UIViewControllerTransitioningDelegate实现dismiss时候的委托方法，包括返回对应的动画以及交互切换Controller</li>
</ol>


<p>完成了，如果向下划动时，效果如下：</p>

<p><img src="http://img.onevcat.com/2013/custom-vc-transition-2.gif" alt="交互驱动的VC转移" /></p>

<h3>关于iOS 7中自定义VC切换的一些总结</h3>

<p>demo中只展示了对于modalVC的present和dismiss的自定义切换效果，当然对与Navigation Controller的Push和Pop切换也是有相应的一套方法的。实现起来和dismiss十分类似，只不过对应UIViewControllerTransitioningDelegate的询问动画和交互的方法换到了UINavigationControllerDelegate中（为了区别push或者pop，看一下这个接口应该能马上知道）。另外一个很好的福利是，对于标准的navController的Pop操作，苹果已经替我们实现了手势驱动返回，我们不用再费心每个去实现一遍了，cheers～</p>

<p>另外，可能你会觉得使用VC容器其提供的transition动画方法来进行VC切换就已经够好够方便了，为什么iOS7中还要引入一套自定义的方式呢。其实从根本来说它们所承担的是两类完全不同的任务：自定义VC容器可以提供自己定义的VC结构，并保证系统的各类方法和通知能够准确传递到合适的VC，它提供的transition方法虽然可以实现一些简单的UIView动画，但是难以重用，可以说是和containerVC完全耦合在一起的；而自定义切换并不改变VC的组织结构，只是负责提供view的效果，因为VC切换将动画部分、动画驱动部分都使用接口的方式给出，因此重用性非常优秀。在绝大多数情况下，精心编写的一套UIView动画是可以轻易地用在不同的VC中，甚至是不同的项目中的。</p>

<p>需要特别一提的是，Github上的<a href="https://github.com/ColinEberhardt/VCTransitionsLibrary">ColinEberhardt的VCTransitionsLibrary</a>已经为我们提供了一系列的VC自定义切换动画效果，正是得益于iOS7中这一块的良好设计（虽然这几个接口的命名比较相似，在弄明白之前会有些confusing），因此这些效果使用起来非常方便，相信一般项目中是足够使用的了。而其他更复杂或者炫目的效果，亦可在其基础上进行扩展改进得到。可以说随着越来越多的应用转向iOS7，自定义VC切换将成为新的用户交互实现的基础和重要部分，对于今后会在其基础上会衍生出怎样让人眼前一亮的交互设计，不妨让我们拭目以待（或者自己努力去创造）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC 2013 Session笔记 - iOS7中弹簧式列表的制作]]></title>
    <link href="http://onevcat.com/2013/09/spring-list-like-ios7-message/"/>
    <updated>2013-09-01T23:03:00+09:00</updated>
    <id>http://onevcat.com/2013/09/spring-list-like-ios7-message</id>
    <content type="html"><![CDATA[<p>这是我的WWDC2013系列笔记中的一篇，完整的笔记列表请参看<a href="http://onevcat.com/2013/06/developer-should-know-about-ios7/">这篇总览</a>。本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">许可协议</a>范围内转载或使用，但是还烦请保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://onevcat.com/atom.xml">RSS</a>或<a href="http://eepurl.com/wNSkj">邮件</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>

<p>本文涉及到的WWDC2013 Session有</p>

<ul>
<li>Session 206 Getting Started with UIKit Dynamics</li>
<li>Session 217 Exploring Scroll Views in iOS7</li>
</ul>


<p>UIScrollView可以说是UIKit中最重要的类之一了，包括UITableView和UICollectionView等重要的数据容器类都是UIScrollView的子类。在历年的WWDC上，UIScrollView和相关的API都有专门的主题进行介绍，也可以看出这个类的使用和变化之快。今年也不例外，因为iOS7完全重新定义了UI，这使得UIScrollView里原来不太会使用的一些用法和实现的效果在新的系统中得到了很好的表现。另外，由于引入了UIKit Dynamics，我们还可以结合ScrollView做出一些以前不太可能或者需要花费很大力气来实现的效果，包括带有重力的swipe或者是类似新的信息app中的带有弹簧效果聊天泡泡等。如果您还不太了解iOS7中信息app的效果，这里有一张gif图可以帮您大概了解一下：</p>

<p><img src="http://img.onevcat.com/2013/ios7-message-app-spring.gif" alt="iOS7中信息app的弹簧效果" /></p>

<p>这次笔记的内容主要就是实现一个这样的效果。为了避免重复造轮子，我对这个效果进行了一些简单的封装，并连同这篇笔记的demo一起扔在了Github上，有需要的童鞋可以<a href="https://github.com/onevcat/VVSpringCollectionViewFlowLayout">到这里</a>自取。</p>

<p>iOS7的SDK中Apple最大的野心其实是想用SpriteKit来结束iOS平台游戏开发（至少是2D游戏开发）的乱战，统一游戏开发的方式并建立良性社区。而UIKit Dynamics，个人猜测Apple在花费力气为SpriteKit开发了物理引擎的同时，发现在UIKit中也可以使用，并能得到不错的效果，于是顺便革新了一下设计理念，在UI设计中引入了不少物理的概念。在iOS系统中，最为典型的应用是锁屏界面打开相机时中途放弃后的重力下坠+反弹的效果，另一个就是信息应用中的加入弹性的消息列表了。弹性列表在我自己上手试过以后觉得表现形式确实很生动，可以消除原来列表那种冷冰冰的感觉，是有可能在今后的设计中被大量使用的，因此决定学上一学。</p>

<p>首先我们需要知道要如何实现这样一种效果，我们会用到哪些东西。毋庸置疑，如果不使用UIKit Dynamics的话，自己从头开始来完成会是一件非常费力的事情，你可能需要实现一套位置计算和物理模拟来使效果看起来真实滑润。而UIKit Dynamics中已经给我们提供了现成的弹簧效果，可以用<code>UIAttachmentBehavior</code>进行实现。另外，在说到弹性效果的时候，我们其实是在描述一个列表中的各个cell之间的关系，对于传统的UITableView来说，描述UITableViewCell之间的关系是比较复杂的（因为Apple已经把绝大多数工作做了，包括计算cell位置和位移等。使用越简单，定制就会越麻烦在绝大多数情况下都是真理）。而UICollectionView则通过layout来完成cell之间位置关系的描述，给了开发者较大的空间来实现布局。另外，UIKit Dynamics为UICollectionView做了很多方便的Catagory，可以很容易地“指导”UICollectionView利用加入物理特性计算后的结果，在实现弹性效果的时候，UICollectionView是我们不二的选择。</p>

<p>如果您在阅读这篇笔记的时候遇到困难的话，建议您可以看看我之前的一些笔记，包括今年的<a href="http://onevcat.com/2013/06/uikit-dynamics-started/">UIKit Dynamics的介绍</a>和去年的<a href="http://onevcat.com/2012/06/introducing-collection-views/">UICollectionView介绍</a>。</p>

<!--more-->


<p>话不多说，我们开工。首先准备一个UICollectionViewFlowLayout的子类（在这里叫做<code>VVSpringCollectionViewFlowLayout</code>），然后在ViewController中用这个layout实现一个简单的collectionView：</p>

<p>```objc
//ViewController.m</p>

<p>@interface ViewController ()&lt;UICollectionViewDataSource, UICollectionViewDelegate>
@property (nonatomic, strong) VVSpringCollectionViewFlowLayout *layout;
@end</p>

<p>static NSString *reuseId = @"collectionViewCellReuseId";</p>

<p>@implementation ViewController
- (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

self.layout = [[VVSpringCollectionViewFlowLayout alloc] init];
self.layout.itemSize = CGSizeMake(self.view.frame.size.width, 44);
UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:self.view.frame collectionViewLayout:self.layout];

collectionView.backgroundColor = [UIColor clearColor];

[collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:reuseId];

collectionView.dataSource = self;
[self.view insertSubview:collectionView atIndex:0];
</code></pre>

<p>}</p>

<h1>pragma mark - UICollectionViewDataSource</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
  return 50;
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
  UICollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseId forIndexPath:indexPath];</p>

<p>  //Just give a random color to the cell. See https://gist.github.com/kylefox/1689973
  cell.contentView.backgroundColor = [UIColor randomColor];
  return cell;
}
@end
```</p></li>
</ul>


<p>这部分没什么可以多说的，现在我们有一个标准的FlowLayout的UICollectionView了。通过使用UICollectionViewFlowLayout的子类来作为开始的layout，我们可以节省下所有的初始cell位置计算的代码，在上面代码的情况下，这个collectionView的表现和一个普通的tableView并没有太大不同。接下来我们着重来看看要如何实现弹性的layout。对于弹性效果，我们需要的是连接一个item和一个锚点间弹性连接的<code>UIAttachmentBehavior</code>，并能在滚动时设置新的锚点位置。我们在scroll的时候，只要使用UIKit Dynamics的计算结果，替代掉原来的位置更新计算（其实就是简单的scrollView的contentOffset的改变），就可以模拟出弹性的效果了。</p>

<p>首先在<code>-prepareLayout</code>中为cell添加<code>UIAttachmentBehavior</code>。</p>

<p>```objc
//VVSpringCollectionViewFlowLayout.m
@interface VVSpringCollectionViewFlowLayout()
@property (nonatomic, strong) UIDynamicAnimator *animator;
@end</p>

<p>@implementation VVSpringCollectionViewFlowLayout
//...</p>

<p>-(void)prepareLayout {</p>

<pre><code>[super prepareLayout];

if (!_animator) {
    _animator = [[UIDynamicAnimator alloc] initWithCollectionViewLayout:self];
    CGSize contentSize = [self collectionViewContentSize];
    NSArray *items = [super layoutAttributesForElementsInRect:CGRectMake(0, 0, contentSize.width, contentSize.height)];

    for (UICollectionViewLayoutAttributes *item in items) {
        UIAttachmentBehavior *spring = [[UIAttachmentBehavior alloc] initWithItem:item attachedToAnchor:item.center];

        spring.length = 0;
        spring.damping = 0.5;
        spring.frequency = 0.8;

        [_animator addBehavior:spring];
    }
}
</code></pre>

<p>}
@end
```</p>

<p>prepareLayout将在CollectionView进行排版的时候被调用。首先当然是call一下super的prepareLayout，你肯定不会想要全都要自己进行设置的。接下来，如果是第一次调用这个方法的话，先初始化一个UIDynamicAnimator实例，来负责之后的动画效果。iOS7 SDK中，UIDynamicAnimator类专门有一个针对UICollectionView的Category，以使UICollectionView能够轻易地利用UIKit Dynamics的结果。在<code>UIDynamicAnimator.h</code>中能够找到这个Category：</p>

<p>```objc
@interface UIDynamicAnimator (UICollectionViewAdditions)</p>

<p>// When you initialize a dynamic animator with this method, you should only associate collection view layout attributes with your behaviors.
// The animator will employ thecollection view layout’s content size coordinate system.
- (instancetype)initWithCollectionViewLayout:(UICollectionViewLayout*)layout;</p>

<p>// The three convenience methods returning layout attributes (if associated to behaviors in the animator) if the animator was configured with collection view layout
- (UICollectionViewLayoutAttributes<em>)layoutAttributesForCellAtIndexPath:(NSIndexPath</em>)indexPath;
- (UICollectionViewLayoutAttributes<em>)layoutAttributesForSupplementaryViewOfKind:(NSString </em>)kind atIndexPath:(NSIndexPath <em>)indexPath;
- (UICollectionViewLayoutAttributes</em>)layoutAttributesForDecorationViewOfKind:(NSString<em>)decorationViewKind atIndexPath:(NSIndexPath </em>)indexPath;</p>

<p>@end
```</p>

<p>于是通过<code>-initWithCollectionViewLayout:</code>进行初始化后，这个UIDynamicAnimator实例便和我们的layout进行了绑定，之后这个layout对应的attributes都应该由绑定的UIDynamicAnimator的实例给出。就像下面这样：</p>

<p>```objc
//VVSpringCollectionViewFlowLayout.m
@implementation VVSpringCollectionViewFlowLayout</p>

<p>//...</p>

<p>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {</p>

<pre><code>return [_animator itemsInRect:rect];
</code></pre>

<p>}</p>

<p>-(UICollectionViewLayoutAttributes <em>)layoutAttributesForItemAtIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>return [_animator layoutAttributesForCellAtIndexPath:indexPath];
</code></pre>

<p>}
@end
```</p>

<p>让我们回到<code>-prepareLayout</code>方法中，在创建了UIDynamicAnimator实例后，我们对于这个layout中的每个attributes对应的点，都创建并添加一个添加一个<code>UIAttachmentBehavior</code>（在iOS7 SDK中，UICollectionViewLayoutAttributes已经实现了UIDynamicItem接口，可以直接参与UIKit Dynamic的计算中去）。创建时我们希望collectionView的每个cell就保持在原位，因此我们设定了锚点为当前attribute本身的center。</p>

<p>接下来我们考虑滑动时的弹性效果的实现。在系统的信息app中，我们可以看到弹性效果有两个特点：</p>

<ul>
<li>随着滑动的速度增大，初始的拉伸和压缩的幅度将变大</li>
<li>随着cell距离屏幕触摸位置越远，拉伸和压缩的幅度</li>
</ul>


<p>对于考虑到这两方面的特点，我们所期望的滑动时的各cell锚点的变化应该是类似这样的：</p>

<p><img src="http://img.onevcat.com/2013/spring-list-ios7.png" alt="向上拖动时的锚点变化示意" /></p>

<p>现在我们来实现这个锚点的变化。既然都是滑动，我们是不是可以考虑在UIScrollView的<code>–scrollViewDidScroll:</code>委托方法中来设定新的Behavior锚点值呢？理论上来说当然是可以的，但是如果这样的话我们大概就不得不面临着将刚才的layout实例设置为collectionView的delegate这样一个事实。但是我们都知道layout应该做的事情是给collectionView提供必要的布局信息，而不应该负责去处理它的委托事件。处理collectionView的回调更恰当地应该由处于collectionView的controller层级的类来完成，而不应该由一个给collectionView提供数据和信息的类来响应。在<code>UICollectionViewLayout</code>中，我们有一个叫做<code>-shouldInvalidateLayoutForBoundsChange:</code>的方法，每次layout的bounds发生变化的时候，collectionView都会询问这个方法是否需要为这个新的边界和更新layout。一般情况下只要layout没有根据边界不同而发生变化的话，这个方法直接不做处理地返回NO，表示保持现在的layout即可，而每次bounds改变时这个方法都会被调用的特点正好可以满足我们更新锚点的需求，因此我们可以在这里面完成锚点的更新。</p>

<p>```objc
//VVSpringCollectionViewFlowLayout.m
@implementation VVSpringCollectionViewFlowLayout</p>

<p>//...</p>

<p>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds {</p>

<pre><code>UIScrollView *scrollView = self.collectionView;
CGFloat scrollDelta = newBounds.origin.y - scrollView.bounds.origin.y;

//Get the touch point
CGPoint touchLocation = [scrollView.panGestureRecognizer locationInView:scrollView];

for (UIAttachmentBehavior *spring in _animator.behaviors) {
    CGPoint anchorPoint = spring.anchorPoint;

    CGFloat distanceFromTouch = fabsf(touchLocation.y - anchorPoint.y);
    CGFloat scrollResistance = distanceFromTouch / 500;

    UICollectionViewLayoutAttributes *item = [spring.items firstObject];
    CGPoint center = item.center;

    //In case the added value bigger than the scrollDelta, which leads an unreasonable effect
    center.y += (scrollDelta &gt; 0) ? MIN(scrollDelta, scrollDelta * scrollResistance)
                                  : MAX(scrollDelta, scrollDelta * scrollResistance);
    item.center = center;

    [_animator updateItemUsingCurrentState:item];
}
return NO;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>首先我们计算了这次scroll的距离<code>scrollDelta</code>，为了得到每个item与触摸点的之间的距离，我们当然还需要知道触摸点的坐标<code>touchLocation</code>。接下来，可以根据距离对每个锚点进行设置了：简单地计算了原来锚点与触摸点之间的距离<code>distanceFromTouch</code>，并由此计算一个系数。接下来，对于当前的item，我们获取其当前锚点位置，然后将其根据<code>scrollDelta</code>的数值和刚才计算的系数，重新设定锚点的位置。最后我们需要告诉UIDynamicAnimator我们已经完成了对冒点的更新，现在可以开始更新物理计算，并随时准备collectionView来取LayoutAttributes的数据了。</p>

<p>也许你还没有缓过神来？但是我们确实已经做完了，让我们来看看实际的效果吧：</p>

<p><img src="http://img.onevcat.com/2013/spring-collection-view-over-ios7.gif" alt="带有弹性效果的collecitonView" /></p>

<p>当然，通过调节<code>damping</code>，<code>frequency</code>和<code>scrollResistance</code>的系数等参数，可以得到弹性不同的效果，比如更多的震荡或者更大的幅度等等。</p>

<p>这个layout实现起来非常简单，我顺便封装了一下放到了Github上，大家有需要的话可以<a href="https://github.com/onevcat/VVSpringCollectionViewFlowLayout">点击这里下载</a>并直接使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[猫都能学会的Unity3D Shader入门指南（二）]]></title>
    <link href="http://onevcat.com/2013/08/shader-tutorial-2/"/>
    <updated>2013-08-31T22:18:00+09:00</updated>
    <id>http://onevcat.com/2013/08/shader-tutorial-2</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/shader-tutorial2-light.jpg" alt="Unity Shader教程" /></p>

<h2>关于本系列</h2>

<p>这是Unity3D Shader入门指南系列的第二篇，本系列面向的对象是新接触Shader开发的Unity3D使用者，因为我本身自己也是Shader初学者，因此可能会存在错误或者疏漏，如果您在Shader开发上有所心得，很欢迎并恳请您指出文中纰漏，我会尽快改正。在<a href="http://onevcat.com/2013/07/shader-tutorial-1/">之前的开篇</a>中介绍了一些Shader的基本知识，包括ShaderLab的基本结构和语法，以及简单逐句地讲解了一个基本的shader。在具有这些基础知识后，阅读简单的shader应该不会有太大问题，在继续教程之前简单阅读一下Unity的<a href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderExamples.html">Surface Shader Example</a>，以检验您是否掌握了上一节的内容。如果您对阅读大部分示例Shader并没有太大问题，可以正确地指出Shader的结构，声明和使用的话，就说明您已经准备好继续阅读本节的内容了。</p>

<h2>法线贴图(Normal Mapping)</h2>

<p>法线贴图是凸凹贴图(Bump mapping)的一种常见应用，简单说就是在不增加模型多边形数量的前提下，通过渲染暗部和亮部的不同颜色深度，来为原来的贴图和模型增加视觉细节和真实效果。简单原理是在普通的贴图的基础上，再另外提供一张对应原来贴图的，可以表示渲染浓淡的贴图。通过将这张附加的表示表面凸凹的贴图的因素于实际的原贴图进行运算后，可以得到新的细节更加丰富富有立体感的渲染效果。在本节中，我们将首先实现一个法线贴图的Shader，然后对Unity Shader的光照模型进行一些讨论，并实现一个自定义的光照模型。最后再通过更改shader模拟一个石头上的积雪效果，并对模型顶点进行一些修改使积雪效果看起来比较真实。在本节结束的时候，我们就会有一个比较强大的可以满足一些真实开发工作时可用的shader了，而且更重要的是，我们将会掌握它是如何被创造出来的。</p>

<!--more-->


<p>关于法线贴图的效果图，可以对比看看下面。模型面数为500，左侧只使用了简单的Diffuse着色，右侧使用了法线贴图。比较两张图片不难发现，使用了法线贴图的石头在暗部和亮部都有着更好的表现。整体来说，凸凹感比Diffuse的结果增强许多，石头看起来更真实也更具有质感。</p>

<p><img src="http://img.onevcat.com/2013/shader-tutorial2-compare.jpg" alt="image" /></p>

<p>本节中需要用到的上面的素材可以<a href="http://vdisk.weibo.com/s/y-NNpUsxhYhZI">在这里下载</a>，其中包括上面的石块的模型，一张贴图以及对应的法线贴图。将下载的package导入到工程中，并新建一个material，使用简单的Diffuse的Shader（比如上一节我们实现的），再加上一个合适的平行光光源，就可以得到我们左图的效果。另外，本节以及以后都会涉及到一些Unity内建的Shader的内容，比如一些标准常用函数和常量定义等，相关内容可以在Unity的内建Shader中找到，内建Shader可以在<a href="http://unity3d.com/unity/download/archive">Unity下载页面</a>的版本右侧找到。</p>

<p>接下来我们实现法线贴图。在实现之前，我们先简单地稍微多了解一些法线贴图的基本知识。大多数法线图一般都和下面的图类似，是一张以蓝紫色为主的图。这张法线图其实是一张RGB贴图，其中红，绿，蓝三个通道分别表示由高度图转换而来的该点的法线指向：Nx、Ny、Nz。在其中绝大部分点的法线都指向z方向，因此图更偏向于蓝色。在shader进行处理时，我们将光照与该点的法线值进行点积后即可得到在该光线下应有的明暗特性，再将其应用到原图上，即可反应在一定光照环境下物体的凹凸关系了。关于法向贴图的更多信息，可以参考<a href="http://en.wikipedia.org/wiki/Normal_mapping">wiki上的相关条目</a>。</p>

<p><img src="http://img.onevcat.com/2013/shader-tutorial2-normal.jpg" alt="一张典型的法线图" /></p>

<p>回到正题，我们现在考虑的主要是Shader入门，而不是图像学的原理。再上一节我们写的Shader的基础上稍微做一些修改，就可以得到适应并完成法线贴图渲染的新Shader。新加入的部分进行了编号并在之后进行说明。</p>

<p>```glsl
Shader "Custom/Normal Mapping" {</p>

<pre><code>Properties {
    _MainTex ("Base (RGB)", 2D) = "white" {}

    //1
    _Bump ("Bump", 2D) = "bump" {}
}
SubShader {
    Tags { "RenderType"="Opaque" }
    LOD 200

    CGPROGRAM
    #pragma surface surf Lambert

    sampler2D _MainTex;

    //2
    sampler2D _Bump;                

    struct Input {
        float2 uv_MainTex;

        //3
        float2 uv_Bump;
    };

    void surf (Input IN, inout SurfaceOutput o) {
        half4 c = tex2D (_MainTex, IN.uv_MainTex);

        //4
        o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump);

        o.Albedo = c.rgb;
        o.Alpha = c.a;
    }
    ENDCG
} 
FallBack "Diffuse"
</code></pre>

<p>}
```</p>

<ol>
<li>声明并加入一个显示名称为<code>Bump</code>的贴图，用于放置法线图</li>
<li>为了能够在CG程序中使用这张贴图，必须加入一个sample，希望你还记得～</li>
<li>获取Bump的uv信息作为输入</li>
<li>从法线图中提取法线信息，并将其赋予相应点的输出的Normal属性。<code>UnpackNormal</code>是定义在UnityCG.cginc文件中的方法，这个文件中包含了一系列常用的CG变量以及方法。<code>UnpackNormal</code>接受一个fixed4的输入，并将其转换为所对应的法线值（fixed3）。在解包得到这个值之后，将其赋给输出的Normal，就可以参与到光线运算中完成接下来的渲染工作了。</li>
</ol>


<p>现在保存并且编译这个Shader，创建新的material并使用这个shader，将石头的材质贴图和法线图分别拖放到Base和Bump里，再将其应用到石头模型上，应该就可以看到右侧图的效果了。</p>

<h2>光照模型</h2>

<p>在我们之前的看到的Shader中（其实也就上一节的基本diffuse和这里的normal mapping），都只使用了Lambert的光照模型（#pragma surface surf Lambert），这是一个很经典的漫反射模型，光强与入射光的方向和反射点处表面法向夹角的余弦成正比。关于Lambert和漫反射的一些详细的计算和推论，可以参看wiki（<a href="http://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert</a>，<a href="http://en.wikipedia.org/wiki/Diffuse_reflection">漫反射</a>）或者其他地方的介绍。一句话的简单解释就是一个点的反射光强是和该点的法线向量和入射光向量和强度和夹角有关系的，其结果就是这两个向量的点积。既然已经知道了光照计算的原理，我们先来看看如何实现一个自己的光照模型吧。</p>

<p>在刚才的Shader上进行如下修改。</p>

<ul>
<li>首先将原来的<code>#pragma</code>行改为这样</li>
</ul>


<p>```glsl</p>

<h1>pragma surface surf CustomDiffuse</h1>

<p>```</p>

<ul>
<li>然后在SubShader块中添加如下代码</li>
</ul>


<p>```glsl
inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) {</p>

<pre><code>float difLight = max(0, dot (s.Normal, lightDir));
float4 col;
col.rgb = s.Albedo * _LightColor0.rgb * (difLight * atten * 2);
col.a = s.Alpha;
return col;
</code></pre>

<p>}
```</p>

<ul>
<li>最后保存，回到Unity。Shader将编译，如果一切正常，你将不会看到新的shader和之前的在材质表现上有任何不同。但是事实上我们现在的shader已经与Unity内建的diffuse光照模型撇清了关系，而在使用我们自己设定的光照模型了。</li>
</ul>


<p>喵的，这些代码都干了些什么！相信你一定会有这样的疑惑...没问题，没有疑惑的话那就不叫初学了，还是一行行讲来。首先正像我们上一篇所说，<code>#pragma</code>语句在这里声明了接下来的Shader的类型，计算调用的方法名，以及指定光照模型。在之前我们一直指定Lambert为光照模型，而现在我们将其换为了CustomDiffuse。</p>

<p>接下来添加的代码是计算光照的实现。shader中对于方法的名称有着比较严格的约定，想要创建一个光照模型，首先要做的是按照规则声明一个光照计算的函数名字，即<code>Lighting&lt;Your Chosen Name&gt;</code>。对于我们的光照模型CustomDiffuse，其计算函数的名称自然就是<code>LightingCustomDiffuse</code>了。光照模型的计算是在surf方法的表面颜色之后，根据输入的光照条件来对原来的颜色在这种光照下的表现进行计算，最后输出新的颜色值给渲染单元完成在屏幕的绘制。</p>

<p>也许你已经猜到了，我们之前用的Lambert光照模型是不是也有一个名字叫LightingLambert的光照计算函数呢？Bingo。在Unity的内建Shader中，有一个Lighting.cginc文件，里面就包含了LightingLambert的实现。也许你也注意到了，我们所实现的LightingCustomDiffuse的内容现在和Unity内建中的LightingLambert是完全一样的，这也就是使用新的shader的原来视觉上没有区别的原因，因为实现确实是完全一样的。</p>

<p>首先来看输入量，<code>SurfaceOutput s</code>这个就是经过表面计算函数surf处理后的输出，我们讲对其上的点根据光线进行处理，<code>fixed3 lightDir</code>是光线的方向，<code>fixed atten</code>表示光衰减的系数。在计算光照的代码中，我们先将输入的s的法线值（在Normal mapping中的话这个值已经是法线图中的对应量了）和输入光线进行点积（dot函数是CG中内置的数学函数，希望你还记得，可以<a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter05.html">参考这里</a>）。点积的结果在-1至1之间，这个值越大表示法线与光线间夹角越小，这个点也就应该越亮。之后使用max来将这个系数结果限制在0到1之间，是为了避免负数情况的存在而导致最终计算的颜色变为负数，输出一团黑，一般来说这是我们不愿意看到的。接下来我们将surf输出的颜色与光线的颜色<code>_LightColor0.rgb</code>（由Unity根据场景中的光源得到的，它在Lighting.cginc中有声明）进行乘积，然后再与刚才计算的光强系数和输入的衰减系数相乘，最后得到在这个光线下的颜色输出（关于difLight * atten * 2中为什么有个乘2，这是一个历史遗留问题，主要是为了进行一些光强补偿，可以参见<a href="http://forum.unity3d.com/threads/94711-Why-(atten-*-2">这里的讨论</a>)）。</p>

<p>在了解了基本实现方式之后，我们可以看看做一些修改玩玩儿。最简单的比如将这个Lambert模型改亮一些，比如换成Half Lambert模型。Half Lambert是由Valve创造的可以使物体在低光线条件下增亮的技术，最早被用于半条命（Half Life）中以避免在低光下物体的走形。简单说就是把光强系数先取一半，然后在加0.5，代码如下：</p>

<p>```glsl
inline float4 LightingCustomDiffuse (SurfaceOutput s, fixed3 lightDir, fixed atten) {</p>

<pre><code>float difLight = dot (s.Normal, lightDir);
float hLambert = difLight * 0.5 + 0.5;
float4 col;
col.rgb = s.Albedo * _LightColor0.rgb * (hLambert * atten * 2);
col.a = s.Alpha;
return col;
</code></pre>

<p>}
```</p>

<p>这样一来，原来光强0的点，现在对应的值变为了0.5，而原来是1的地方现在将保持为1。也就是说模型贴图的暗部被增强变亮了，而亮部基本保持和原来一样，防止过曝。使用Half Lambert前后的效果图如下，注意最右侧石头下方的阴影处细节更加明显了，而这一切都只是视觉效果的改变，不涉及任何贴图和模型的变化。</p>

<p><img src="http://img.onevcat.com/2013/shader-toturial-hl.jpg" alt="Half Lambert下发现贴图的表现" /></p>

<h2>表面贴图的追加效果</h2>

<p>OK，对于光线和自定义光照模型的讨论暂时到此为止，因为如果展开的话这将会一个庞大的图形学和经典光学的话题了。我们回到Shader，并且一起实现一些激动人心的效果吧。比如，在你的游戏场景中有一幕是雪地场景，而你希望做一些石头上白雪皑皑的覆盖效果，应该怎么办呢？难道让你可爱的3D设计师再去出一套覆雪的贴图然后使用新的贴图？当然不，不是不能，而是不该。因为新的贴图不仅会增大项目的资源包体积，更会增大之后修改和维护的难度，想想要是有好多石头需要实现同样的覆雪效果，或者是要随着游戏时间堆积的雪逐渐变多的话，你应该怎么办？难道让设计师再把所有的石头贴图都盖上雪，然后再按照雪的厚度出5套不同的贴图么？相信我，他们会疯的。</p>

<p>于是，我们考虑用Shader来完成这件工作吧！先考虑下我们需要什么，积雪效果的话，我们需要积雪等级（用来表示积雪量），雪的颜色，以及积雪的方向。基本思路和实现自定义光照模型类似，通过计算原图的点在世界坐标中的法线方向与积雪方向的点积，如果大于设定的积雪等级的阈值的话则表示这个方向与积雪方向是一致的，其上是可以积雪的，显示雪的颜色，否则使用原贴图的颜色。废话不再多说，上代码，在上面的Shader的基础上，更改Properties里的内容为</p>

<p>```glsl
Properties {</p>

<pre><code>_MainTex ("Base (RGB)", 2D) = "white" {}
_Bump ("Bump", 2D) = "bump" {}
_Snow ("Snow Level", Range(0,1) ) = 0
_SnowColor ("Snow Color", Color) = (1.0,1.0,1.0,1.0)
_SnowDirection ("Snow Direction", Vector) = (0,1,0)
</code></pre>

<p>}
```</p>

<p>没有太多值得说的，唯一要提一下的是_SnowDirection设定的默认值为(0,1,0)，这表示我们希望雪是垂直落下的。对应地，在CG程序中对这些变量进行声明：</p>

<p><code>glsl
sampler2D _MainTex;
sampler2D _Bump;
float _Snow;
float4 _SnowColor;
float4 _SnowDirection;
</code></p>

<p>接下来改变Input的内容：</p>

<p>```glsl
struct Input {</p>

<pre><code>float2 uv_MainTex;
float2 uv_Bump;
float3 worldNormal; INTERNAL_DATA
</code></pre>

<p>};
```</p>

<p>相对于上面的Shader输入来说，加入了一个<code>float3 worldNormal; INTERNAL_DATA</code>，如果SurfaceOutput中设定了Normal值的话，通过worldNormal可以获取当前点在世界中的法线值。详细的解说可以参见<a href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html">Unity的Shader文档</a>。接下来可以改变surf函数，实装积雪效果了。</p>

<p>```glsl
void surf (Input IN, inout SurfaceOutput o) {</p>

<pre><code>half4 c = tex2D (_MainTex, IN.uv_MainTex);
o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump));

if (dot(WorldNormalVector(IN, o.Normal), _SnowDirection.xyz) &gt; lerp(1,-1,_Snow)) {
    o.Albedo = _SnowColor.rgb;
} else {
    o.Albedo = c.rgb;
}

o.Alpha = c.a;
</code></pre>

<p>}
```</p>

<p>和上面相比，加入了一个if…else…的判断。首先看这个条件的不等式的左侧，我们对雪的方向和和输入点的世界法线方向进行点积。<code>WorldNormalVector</code>通过输入的点及这个点的法线值，来计算它在世界坐标中的方向；右侧的lerp函数相信只要对插值有概念的同学都不难理解：当<em>Snow取最小值0时，这个函数将返回1，而</em>Snow取最大值时，返回-1。这样我们就可以通过设定<em>Snow的值来控制积雪的阈值，要是积雪等级</em>Snow是0时，不等式左侧不可能大于右侧，因此完全没有积雪；相反要是_Snow取最大值1时，由于左侧必定大于-1，所以全模型积雪。而随着取中间值的变化，积雪的情况便会有所不同。</p>

<p>应用这个Shader，并且适当地调节一下积雪等级和颜色，可以得到如下右边的效果。</p>

<p><img src="http://img.onevcat.com/2013/shader-tutorial2-snow.jpg" alt="添加了积雪效果的Shader" /></p>

<h2>更改顶点模型</h2>

<p>到现在位置，我们还仅指是在原贴图上进行操作，不管是用法线图使模型看起来凸凹有致，还是加上积雪，所有的计算和颜色的输出都只是“障眼法”，并没有对模型有任何实质的改动。但是对于积雪效果来说，实际上积雪是附加到石头上面，而不应当简单替换掉原来的颜色。但是具体实施起来，最简单的办法还是直接替换颜色，但是我们可以稍微变更一下模型，使原来的模型在积雪的方向稍微变大一些，这样来达到一种雪是附加到石头上的效果。</p>

<p>我们继续修改之前的Shader，首先我们需要告诉surface shadow我们要改变模型的顶点。首先将#param行改为</p>

<p><code>#pragma surface surf CustomDiffuse vertex:vert</code></p>

<p>这告诉Shader我们想要改变模型顶点，并且我们会写一个叫做<code>vert</code>的函数来改变顶点。接下来我们再添加一个参数，在Properties中声明一个<code>_SnowDepth</code>变量，表示积雪的厚度，当然我们也需要在CG段中进行声明：</p>

<p>```glsl
//In Properties{…}
_SnowDepth ("Snow Depth", Range(0,0.3)) = 0.1</p>

<p>//In CG declare
float _SnowDepth;
```</p>

<p>接下来实现vert方法，和之前积雪的运算其实比较类似，判断点积大小来决定是否需要扩大模型以及确定模型扩大的方向。在CG段中加入以下vert方法</p>

<p>```glsl
void vert (inout appdata_full v) {</p>

<pre><code>float4 sn = mul(transpose(_Object2World) , _SnowDirection);
if(dot(v.normal, sn.xyz) &gt;= lerp(1,-1, (_Snow * 2) / 3)) {
    v.vertex.xyz += (sn.xyz + v.normal) * _SnowDepth * _Snow;
}
</code></pre>

<p>}
```</p>

<p>和surf的原理差不多，系统会输入一个当前的顶点的值，我们根据需要计算并填上新的值作为返回即可。上面第一行中使用<code>transpose</code>方法输出原矩阵的转置矩阵，在这里_Object2World是Unity ShaderLab的内建值，它表示将当前模型转换到世界坐标中的矩阵，将其与积雪方向做矩阵乘积得到积雪方向在物体的世界空间中的投影（把积雪方向转换到世界坐标中）。之后我们计算了这个世界坐标中实际的积雪方向和当前点的法线值的点积，并将结果与使用积雪等级的2/3进行比较lerp后的阈值比较。这样，当前点如果和积雪方向一致，并且积雪较为完整的话，将改变该点的模型顶点高度。</p>

<p>加入模型更改前后的效果对比如下图，加入模型调整的右图表现要更为丰满真实。</p>

<p><img src="http://img.onevcat.com/2013/shader-tutorial2-snow-vert.jpg" alt="image" /></p>

<p>这节就到这里吧。本节中实现的Shader可以<a href="https://gist.github.com/onevcat/6396814">在这里找到完整版本</a>进行参考，希望大家周末愉快～</p>
]]></content>
  </entry>
  
</feed>
